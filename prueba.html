<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>WebGL 3D Cube</title>
</head>
<body>
    <canvas id="myCanvas" width="400" height="400"></canvas>

    <script>
        var canvas = document.getElementById('myCanvas');
        var gl = canvas.getContext('webgl');

        if (!gl) {
            console.log('Tu navegador no es compatible con WebGL.');
        }

        // Definir las coordenadas de los vértices del cubo
        var vertices = [
            // Cara frontal
            -1.0, -1.0,  1.0,
             1.0, -1.0,  1.0,
             1.0,  1.0,  1.0,
            -1.0,  1.0,  1.0,

            // Cara trasera
            -1.0, -1.0, -1.0,
             1.0, -1.0, -1.0,
             1.0,  1.0, -1.0,
            -1.0,  1.0, -1.0
        ];

        // Crear un búfer de vértices
        var vertexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);

        // Definir los índices para dibujar el cubo
        var indices = [
            0, 1, 2, 0, 2, 3,  // Cara frontal
            4, 5, 6, 4, 6, 7,  // Cara trasera
            0, 3, 7, 0, 7, 4,  // Lado izquierdo
            1, 2, 6, 1, 6, 5,  // Lado derecho
            0, 1, 5, 0, 5, 4,  // Lado inferior
            2, 3, 7, 2, 7, 6   // Lado superior
        ];

        // Crear un búfer de índices
        var indexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);

        // Vertex shader
        var vsSource = `
            attribute vec3 coordinates;
            uniform mat4 modelViewMatrix;
            uniform mat4 projectionMatrix;
            void main(void) {
                gl_Position = projectionMatrix * modelViewMatrix * vec4(coordinates, 1.0);
            }`;

        // Fragment shader
        var fsSource = `
            void main(void) {
                gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0); // Color rojo
            }`;

        // Crear shaders
        var vertexShader = gl.createShader(gl.VERTEX_SHADER);
        var fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);

        // Compilar shaders
        gl.shaderSource(vertexShader, vsSource);
        gl.shaderSource(fragmentShader, fsSource);

        gl.compileShader(vertexShader);
        gl.compileShader(fragmentShader);

        // Crear un programa de shaders
        var shaderProgram = gl.createProgram();
        gl.attachShader(shaderProgram, vertexShader);
        gl.attachShader(shaderProgram, fragmentShader);
        gl.linkProgram(shaderProgram);
        gl.useProgram(shaderProgram);

        // Enlazar el búfer de vértices al atributo de coordenadas
        var coord = gl.getAttribLocation(shaderProgram, 'coordinates');
        gl.enableVertexAttribArray(coord);
        gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
        gl.vertexAttribPointer(coord, 3, gl.FLOAT, false, 0, 0);

        // Configurar matrices de proyección y modelo-vista
        var projectionMatrix = mat4.create();
        var modelViewMatrix = mat4.create();
        var angle = 0.0;

        // Función para actualizar y renderizar el cubo
        function render() {
            angle += 0.01; // Incrementar el ángulo de rotación

            // Configurar la matriz de proyección
            var fov = Math.PI / 4;
            var aspect = canvas.width / canvas.height;
            var near = 0.1;
            var far = 100.0;
            mat4.perspective(projectionMatrix, fov, aspect, near, far);

            // Configurar la matriz de modelo-vista (rotación)
            mat4.identity(modelViewMatrix);
            mat4.translate(modelViewMatrix, modelViewMatrix, [0.0, 0.0, -5.0]);
            mat4.rotate(modelViewMatrix, modelViewMatrix, angle, [1.0, 1.0, 1.0]);

            // Obtener las ubicaciones de las matrices en los shaders
            var projectionMatrixLocation = gl.getUniformLocation(shaderProgram, 'projectionMatrix');
            var modelViewMatrixLocation = gl.getUniformLocation(shaderProgram, 'modelViewMatrix');

            // Enviar matrices al shader
            gl.uniformMatrix4fv(projectionMatrixLocation, false, projectionMatrix);
            gl.uniformMatrix4fv(modelViewMatrixLocation, false, modelViewMatrix);

            // Borrar el lienzo antes de dibujar
            gl.clearColor(0.0, 0.0, 0.0, 1.0);
            gl.clear(gl.COLOR_BUFFER_BIT);

            // Dibujar el cubo
            gl.drawElements(gl.TRIANGLES, indices.length, gl.UNSIGNED_SHORT, 0);

            // Solicitar una nueva animación
            requestAnimationFrame(render);
        }

        // Iniciar la animación
        render();
    </script>
</body>
</html>
